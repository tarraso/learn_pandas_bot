#!/usr/bin/env python
"""Script to add 100 more multiple choice questions about pandas."""

import init_django
from questions.models import Topic, Question

# Дополнительные вопросы по теме "Основы DataFrame"
dataframe_questions_2 = [
    {
        "difficulty": "beginner",
        "question_text": "Как узнать количество строк в DataFrame?",
        "option_a": "len(df)",
        "option_b": "df.length",
        "option_c": "df.rows",
        "option_d": "df.count_rows()",
        "correct_option": "A",
        "explanation": "len(df) возвращает количество строк в DataFrame.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как вывести краткую информацию о DataFrame?",
        "option_a": "df.summary()",
        "option_b": "df.info()",
        "option_c": "df.describe()",
        "option_d": "df.overview()",
        "correct_option": "B",
        "explanation": "info() выводит информацию о типах данных, памяти и количестве непустых значений.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить статистическое описание числовых колонок?",
        "option_a": "df.stats()",
        "option_b": "df.summary()",
        "option_c": "df.describe()",
        "option_d": "df.statistics()",
        "correct_option": "C",
        "explanation": "describe() возвращает статистики: count, mean, std, min, max и квартили.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как создать DataFrame из списка словарей?",
        "option_a": "pd.DataFrame([{}, {}])",
        "option_b": "pd.from_dict([{}, {}])",
        "option_c": "pd.list_to_df([{}, {}])",
        "option_d": "pd.create([{}, {}])",
        "correct_option": "A",
        "explanation": "pd.DataFrame() автоматически конвертирует список словарей в DataFrame.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как транспонировать DataFrame (поменять строки и столбцы местами)?",
        "option_a": "df.transpose()",
        "option_b": "df.T",
        "option_c": "df.swap()",
        "option_d": "Оба A и B",
        "correct_option": "D",
        "explanation": "Можно использовать как df.T, так и df.transpose().",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как добавить новую колонку в DataFrame?",
        "option_a": "df['new_col'] = values",
        "option_b": "df.add_column('new_col', values)",
        "option_c": "df.insert('new_col', values)",
        "option_d": "df.append_col('new_col', values)",
        "correct_option": "A",
        "explanation": "Присваивание через квадратные скобки создает новую колонку.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как создать копию DataFrame?",
        "option_a": "df.copy()",
        "option_b": "df.clone()",
        "option_c": "df.duplicate()",
        "option_d": "copy(df)",
        "correct_option": "A",
        "explanation": "copy() создает глубокую копию DataFrame.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Что делает df.astype()?",
        "option_a": "Проверяет тип данных",
        "option_b": "Преобразует тип данных колонок",
        "option_c": "Удаляет колонки определенного типа",
        "option_d": "Ничего",
        "correct_option": "B",
        "explanation": "astype() изменяет тип данных одной или нескольких колонок.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить уникальные значения из колонки?",
        "option_a": "df['col'].unique()",
        "option_b": "df['col'].distinct()",
        "option_c": "df['col'].uniq()",
        "option_d": "unique(df['col'])",
        "correct_option": "A",
        "explanation": "unique() возвращает массив уникальных значений колонки.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как проверить, является ли DataFrame пустым?",
        "option_a": "df.empty",
        "option_b": "df.is_empty()",
        "option_c": "len(df) == 0",
        "option_d": "Оба A и C",
        "correct_option": "D",
        "explanation": "Можно использовать атрибут empty или проверить длину.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как установить определенную колонку в качестве индекса?",
        "option_a": "df.set_index('col')",
        "option_b": "df.index = 'col'",
        "option_c": "df.make_index('col')",
        "option_d": "df.to_index('col')",
        "correct_option": "A",
        "explanation": "set_index() устанавливает одну или несколько колонок как индекс.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как объединить два DataFrame вертикально (добавить строки)?",
        "option_a": "pd.concat([df1, df2])",
        "option_b": "pd.merge(df1, df2)",
        "option_c": "df1.append(df2)",
        "option_d": "Оба A и C",
        "correct_option": "D",
        "explanation": "Можно использовать concat() или append() для вертикального объединения.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как удалить дубликаты строк?",
        "option_a": "df.drop_duplicates()",
        "option_b": "df.remove_duplicates()",
        "option_c": "df.unique_rows()",
        "option_d": "df.dedupe()",
        "correct_option": "A",
        "explanation": "drop_duplicates() удаляет повторяющиеся строки.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить названия всех индексов?",
        "option_a": "df.index",
        "option_b": "df.indexes",
        "option_c": "df.row_names",
        "option_d": "df.get_index()",
        "correct_option": "A",
        "explanation": "Атрибут index содержит индекс DataFrame.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как применить функцию к каждому элементу DataFrame?",
        "option_a": "df.applymap(func)",
        "option_b": "df.map(func)",
        "option_c": "df.apply_all(func)",
        "option_d": "df.foreach(func)",
        "correct_option": "A",
        "explanation": "applymap() применяет функцию к каждому элементу DataFrame.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как сохранить DataFrame в CSV файл?",
        "option_a": "df.to_csv('file.csv')",
        "option_b": "df.save_csv('file.csv')",
        "option_c": "df.export('file.csv')",
        "option_d": "df.write_csv('file.csv')",
        "correct_option": "A",
        "explanation": "to_csv() экспортирует DataFrame в CSV файл.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как прочитать CSV файл в DataFrame?",
        "option_a": "pd.read_csv('file.csv')",
        "option_b": "pd.load_csv('file.csv')",
        "option_c": "pd.from_csv('file.csv')",
        "option_d": "pd.import_csv('file.csv')",
        "correct_option": "A",
        "explanation": "read_csv() читает CSV файл и создает DataFrame.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать случайные строки из DataFrame?",
        "option_a": "df.sample(n=5)",
        "option_b": "df.random(5)",
        "option_c": "df.choose(5)",
        "option_d": "df.select_random(5)",
        "correct_option": "A",
        "explanation": "sample() выбирает случайные строки, n задает количество.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как изменить порядок колонок в DataFrame?",
        "option_a": "df[['col2', 'col1', 'col3']]",
        "option_b": "df.reorder(['col2', 'col1', 'col3'])",
        "option_c": "df.sort_columns(['col2', 'col1', 'col3'])",
        "option_d": "df.arrange(['col2', 'col1', 'col3'])",
        "correct_option": "A",
        "explanation": "Выбор колонок в нужном порядке создает новый DataFrame с измененным порядком.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как найти корреляцию между колонками?",
        "option_a": "df.corr()",
        "option_b": "df.correlation()",
        "option_c": "df.correlate()",
        "option_d": "df.cor()",
        "correct_option": "A",
        "explanation": "corr() вычисляет корреляционную матрицу для числовых колонок.",
    },
]

# Дополнительные вопросы по теме "Основы Series"
series_questions_2 = [
    {
        "difficulty": "beginner",
        "question_text": "Как создать Series с пользовательским индексом?",
        "option_a": "pd.Series(data, index=[...])",
        "option_b": "pd.Series(data).set_index([...])",
        "option_c": "pd.Series(index=[...], data)",
        "option_d": "pd.Series(data, idx=[...])",
        "correct_option": "A",
        "explanation": "Параметр index в конструкторе Series задает пользовательский индекс.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить n наибольших значений из Series?",
        "option_a": "series.nlargest(n)",
        "option_b": "series.top(n)",
        "option_c": "series.max(n)",
        "option_d": "series.largest(n)",
        "correct_option": "A",
        "explanation": "nlargest(n) возвращает n наибольших значений.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить n наименьших значений из Series?",
        "option_a": "series.nsmallest(n)",
        "option_b": "series.bottom(n)",
        "option_c": "series.min(n)",
        "option_d": "series.smallest(n)",
        "correct_option": "A",
        "explanation": "nsmallest(n) возвращает n наименьших значений.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить сумму всех элементов Series?",
        "option_a": "series.sum()",
        "option_b": "series.total()",
        "option_c": "sum(series)",
        "option_d": "Оба A и C",
        "correct_option": "D",
        "explanation": "Можно использовать метод sum() или встроенную функцию sum().",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как заменить значения в Series?",
        "option_a": "series.replace(old, new)",
        "option_b": "series.change(old, new)",
        "option_c": "series.substitute(old, new)",
        "option_d": "series.swap(old, new)",
        "correct_option": "A",
        "explanation": "replace() заменяет указанные значения на новые.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как создать Series из словаря?",
        "option_a": "pd.Series({'a': 1, 'b': 2})",
        "option_b": "pd.Series.from_dict({'a': 1, 'b': 2})",
        "option_c": "pd.dict_to_series({'a': 1, 'b': 2})",
        "option_d": "pd.create_series({'a': 1, 'b': 2})",
        "correct_option": "A",
        "explanation": "pd.Series() автоматически конвертирует словарь, используя ключи как индексы.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить среднее значение Series?",
        "option_a": "series.mean()",
        "option_b": "series.avg()",
        "option_c": "series.average()",
        "option_d": "mean(series)",
        "correct_option": "A",
        "explanation": "mean() вычисляет среднее арифметическое значений.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как отсортировать Series по значениям?",
        "option_a": "series.sort_values()",
        "option_b": "series.sort()",
        "option_c": "series.order()",
        "option_d": "sorted(series)",
        "correct_option": "A",
        "explanation": "sort_values() сортирует Series по значениям.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как отсортировать Series по индексу?",
        "option_a": "series.sort_index()",
        "option_b": "series.sort_by_index()",
        "option_c": "series.order_index()",
        "option_d": "series.index_sort()",
        "correct_option": "A",
        "explanation": "sort_index() сортирует Series по значениям индекса.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как найти медиану в Series?",
        "option_a": "series.median()",
        "option_b": "series.mid()",
        "option_c": "series.middle()",
        "option_d": "median(series)",
        "correct_option": "A",
        "explanation": "median() вычисляет медианное значение.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить стандартное отклонение Series?",
        "option_a": "series.std()",
        "option_b": "series.stdev()",
        "option_c": "series.stddev()",
        "option_d": "series.sd()",
        "correct_option": "A",
        "explanation": "std() вычисляет стандартное отклонение.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как проверить, содержится ли значение в Series?",
        "option_a": "value in series.values",
        "option_b": "series.contains(value)",
        "option_c": "series.has(value)",
        "option_d": "series.includes(value)",
        "correct_option": "A",
        "explanation": "Оператор in работает с series.values для проверки наличия значения.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как получить кумулятивную сумму Series?",
        "option_a": "series.cumsum()",
        "option_b": "series.cumulative_sum()",
        "option_c": "series.running_sum()",
        "option_d": "series.acc_sum()",
        "correct_option": "A",
        "explanation": "cumsum() вычисляет кумулятивную (накопительную) сумму.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как округлить все значения в Series?",
        "option_a": "series.round(n)",
        "option_b": "series.ceil(n)",
        "option_c": "series.floor(n)",
        "option_d": "round(series, n)",
        "correct_option": "A",
        "explanation": "round(n) округляет значения до n знаков после запятой.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как конвертировать Series в список?",
        "option_a": "series.tolist()",
        "option_b": "list(series)",
        "option_c": "series.to_list()",
        "option_d": "Оба A и B",
        "correct_option": "D",
        "explanation": "Можно использовать tolist() или встроенную функцию list().",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как найти процентили в Series?",
        "option_a": "series.quantile([0.25, 0.75])",
        "option_b": "series.percentile([25, 75])",
        "option_c": "series.quartile([0.25, 0.75])",
        "option_d": "series.pct([0.25, 0.75])",
        "correct_option": "A",
        "explanation": "quantile() вычисляет квантили (процентили) для Series.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как проверить монотонность Series (всегда возрастает)?",
        "option_a": "series.is_monotonic_increasing",
        "option_b": "series.is_increasing()",
        "option_c": "series.monotonic()",
        "option_d": "series.check_monotonic()",
        "correct_option": "A",
        "explanation": "is_monotonic_increasing проверяет, возрастают ли значения монотонно.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить абсолютные значения Series?",
        "option_a": "series.abs()",
        "option_b": "abs(series)",
        "option_c": "series.absolute()",
        "option_d": "Оба A и B",
        "correct_option": "D",
        "explanation": "Можно использовать метод abs() или функцию abs().",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как заполнить Series определенным значением?",
        "option_a": "pd.Series([value] * n)",
        "option_b": "pd.fill(value, n)",
        "option_c": "pd.repeat(value, n)",
        "option_d": "pd.Series(value, index=range(n))",
        "correct_option": "D",
        "explanation": "Можно создать Series, передав скаляр и индекс нужной длины.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как применить условие к Series и вернуть разные значения?",
        "option_a": "np.where(series > 0, 'positive', 'negative')",
        "option_b": "series.if_else(series > 0, 'positive', 'negative')",
        "option_c": "series.case_when(series > 0, 'positive', 'negative')",
        "option_d": "series.conditional('positive', 'negative')",
        "correct_option": "A",
        "explanation": "numpy.where() позволяет применить условие и вернуть разные значения.",
    },
]

# Дополнительные вопросы по теме "Индексация и выбор данных"
indexing_questions_2 = [
    {
        "difficulty": "beginner",
        "question_text": "Как выбрать строки с индексами от 'a' до 'c' включительно?",
        "option_a": "df.loc['a':'c']",
        "option_b": "df.iloc['a':'c']",
        "option_c": "df['a':'c']",
        "option_d": "df.select('a':'c')",
        "correct_option": "A",
        "explanation": "loc с срезом включает оба конца интервала (в отличие от обычных срезов Python).",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать каждую вторую строку?",
        "option_a": "df.iloc[::2]",
        "option_b": "df[::2]",
        "option_c": "df.every(2)",
        "option_d": "df.step(2)",
        "correct_option": "A",
        "explanation": "iloc[::2] выбирает каждую вторую строку, используя шаг среза.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как выбрать строки по списку булевых значений?",
        "option_a": "df[[True, False, True, ...]]",
        "option_b": "df.loc[[True, False, True, ...]]",
        "option_c": "df.select([True, False, True, ...])",
        "option_d": "Оба A и B",
        "correct_option": "D",
        "explanation": "Можно передать булевый список напрямую или через loc.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать строки где значение НЕ равно определенному?",
        "option_a": "df[df['col'] != value]",
        "option_b": "df[df['col'].ne(value)]",
        "option_c": "df[~(df['col'] == value)]",
        "option_d": "Все варианты",
        "correct_option": "D",
        "explanation": "Все три способа эквивалентны для проверки неравенства.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как выбрать первую колонку DataFrame?",
        "option_a": "df.iloc[:, 0]",
        "option_b": "df[0]",
        "option_c": "df.col(0)",
        "option_d": "df.first_column()",
        "correct_option": "A",
        "explanation": "iloc[:, 0] выбирает все строки (:) и первую колонку (0).",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как выбрать элементы по нескольким условиям (И)?",
        "option_a": "df[(df['col1'] > 5) & (df['col2'] < 10)]",
        "option_b": "df[df['col1'] > 5 and df['col2'] < 10]",
        "option_c": "df.query('col1 > 5 and col2 < 10')",
        "option_d": "Оба A и C",
        "correct_option": "D",
        "explanation": "Можно использовать & с скобками или метод query().",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать элементы по нескольким условиям (ИЛИ)?",
        "option_a": "df[(df['col1'] > 5) | (df['col2'] < 10)]",
        "option_b": "df[df['col1'] > 5 or df['col2'] < 10]",
        "option_c": "df.query('col1 > 5 or col2 < 10')",
        "option_d": "Оба A и C",
        "correct_option": "D",
        "explanation": "Можно использовать | с скобками или метод query().",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить значение конкретной ячейки по позиции?",
        "option_a": "df.iat[row, col]",
        "option_b": "df.get(row, col)",
        "option_c": "df.cell(row, col)",
        "option_d": "df[row, col]",
        "correct_option": "A",
        "explanation": "iat обеспечивает быстрый доступ к скаляру по целочисленной позиции.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как выбрать строки где строка содержит подстроку?",
        "option_a": "df[df['col'].str.contains('pattern')]",
        "option_b": "df[df['col'].contains('pattern')]",
        "option_c": "df[df['col'].has('pattern')]",
        "option_d": "df.filter('col', 'pattern')",
        "correct_option": "A",
        "explanation": "str.contains() проверяет наличие подстроки в строковых значениях.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать строки где значение больше среднего?",
        "option_a": "df[df['col'] > df['col'].mean()]",
        "option_b": "df.above_mean('col')",
        "option_c": "df.filter('col', '> mean')",
        "option_d": "df.query('col > mean')",
        "correct_option": "A",
        "explanation": "Сравнение колонки с её средним значением создает булевую маску.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как выбрать строки с определенными значениями индекса?",
        "option_a": "df.loc[['index1', 'index2']]",
        "option_b": "df.iloc[['index1', 'index2']]",
        "option_c": "df[['index1', 'index2']]",
        "option_d": "df.select(['index1', 'index2'])",
        "correct_option": "A",
        "explanation": "loc принимает список меток индекса для выбора строк.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как выбрать строки где все значения не null?",
        "option_a": "df[df.notna().all(axis=1)]",
        "option_b": "df[df.notnull().all(axis=1)]",
        "option_c": "df.dropna()",
        "option_d": "Все варианты",
        "correct_option": "D",
        "explanation": "Все три способа выбирают строки без пропущенных значений.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать колонки определенного типа данных?",
        "option_a": "df.select_dtypes(include='int64')",
        "option_b": "df.select_types('int64')",
        "option_c": "df.filter_dtypes('int64')",
        "option_d": "df.get_dtypes('int64')",
        "correct_option": "A",
        "explanation": "select_dtypes() фильтрует колонки по типу данных.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как выбрать последнюю строку DataFrame?",
        "option_a": "df.iloc[-1]",
        "option_b": "df.last()",
        "option_c": "df.tail(1)",
        "option_d": "Оба A и C",
        "correct_option": "D",
        "explanation": "iloc[-1] или tail(1) возвращают последнюю строку.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как использовать query для фильтрации?",
        "option_a": "df.query('col > 5')",
        "option_b": "df.filter('col > 5')",
        "option_c": "df.where('col > 5')",
        "option_d": "df.select('col > 5')",
        "correct_option": "A",
        "explanation": "query() позволяет использовать строковые выражения для фильтрации.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать случайную выборку строк?",
        "option_a": "df.sample(frac=0.1)",
        "option_b": "df.random(0.1)",
        "option_c": "df.sample_random(0.1)",
        "option_d": "df.choose(0.1)",
        "correct_option": "A",
        "explanation": "sample(frac=0.1) выбирает 10% случайных строк.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как выбрать строки по регулярному выражению?",
        "option_a": "df[df['col'].str.match(r'pattern')]",
        "option_b": "df[df['col'].regex(r'pattern')]",
        "option_c": "df.filter_regex('col', r'pattern')",
        "option_d": "df.match('col', r'pattern')",
        "correct_option": "A",
        "explanation": "str.match() проверяет соответствие регулярному выражению.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как выбрать первые 3 колонки?",
        "option_a": "df.iloc[:, :3]",
        "option_b": "df[:3]",
        "option_c": "df.head(3, axis=1)",
        "option_d": "df.cols[:3]",
        "correct_option": "A",
        "explanation": "iloc[:, :3] выбирает все строки и первые 3 колонки.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать строки с индексом больше определенного значения?",
        "option_a": "df[df.index > value]",
        "option_b": "df.loc[df.index > value]",
        "option_c": "df.filter_index(value)",
        "option_d": "Оба A и B",
        "correct_option": "D",
        "explanation": "Можно использовать булевую маску на индексе напрямую или через loc.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как выбрать строки где хотя бы одно значение null?",
        "option_a": "df[df.isna().any(axis=1)]",
        "option_b": "df[df.isnull().any(axis=1)]",
        "option_c": "df[~df.notna().all(axis=1)]",
        "option_d": "Все варианты",
        "correct_option": "D",
        "explanation": "Все три способа выбирают строки с хотя бы одним пропущенным значением.",
    },
]

# Дополнительные вопросы по теме "GroupBy и агрегация"
groupby_questions_2 = [
    {
        "difficulty": "beginner",
        "question_text": "Как посчитать среднее для каждой группы?",
        "option_a": "groupby().mean()",
        "option_b": "groupby().avg()",
        "option_c": "groupby().average()",
        "option_d": "groupby().mean_value()",
        "correct_option": "A",
        "explanation": "mean() вычисляет среднее значение для каждой группы.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить минимальное значение в каждой группе?",
        "option_a": "groupby().min()",
        "option_b": "groupby().minimum()",
        "option_c": "groupby().smallest()",
        "option_d": "groupby().lowest()",
        "correct_option": "A",
        "explanation": "min() возвращает минимальное значение для каждой группы.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как применить пользовательскую функцию к группам?",
        "option_a": "groupby().apply(lambda x: custom_func(x))",
        "option_b": "groupby().custom(custom_func)",
        "option_c": "groupby().function(custom_func)",
        "option_d": "groupby().exec(custom_func)",
        "correct_option": "A",
        "explanation": "apply() с lambda или функцией применяет её к каждой группе.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как посчитать количество непустых значений в группе?",
        "option_a": "groupby().count()",
        "option_b": "groupby().num()",
        "option_c": "groupby().total()",
        "option_d": "groupby().length()",
        "correct_option": "A",
        "explanation": "count() подсчитывает непустые значения в каждой группе.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить стандартное отклонение для групп?",
        "option_a": "groupby().std()",
        "option_b": "groupby().stdev()",
        "option_c": "groupby().stddev()",
        "option_d": "groupby().deviation()",
        "correct_option": "A",
        "explanation": "std() вычисляет стандартное отклонение для каждой группы.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как получить медиану для каждой группы?",
        "option_a": "groupby().median()",
        "option_b": "groupby().mid()",
        "option_c": "groupby().middle()",
        "option_d": "groupby().center()",
        "correct_option": "A",
        "explanation": "median() вычисляет медиану для каждой группы.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить последнюю строку каждой группы?",
        "option_a": "groupby().last()",
        "option_b": "groupby().tail(1)",
        "option_c": "groupby().final()",
        "option_d": "groupby().end()",
        "correct_option": "A",
        "explanation": "last() возвращает последнее ненулевое значение каждой группы.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как вычислить дисперсию для групп?",
        "option_a": "groupby().var()",
        "option_b": "groupby().variance()",
        "option_c": "groupby().dispersion()",
        "option_d": "groupby().spread()",
        "correct_option": "A",
        "explanation": "var() вычисляет дисперсию для каждой группы.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как нормализовать значения внутри каждой группы?",
        "option_a": "groupby().transform(lambda x: (x - x.mean()) / x.std())",
        "option_b": "groupby().normalize()",
        "option_c": "groupby().standardize()",
        "option_d": "groupby().scale()",
        "correct_option": "A",
        "explanation": "transform() с формулой z-score нормализует значения в группе.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить n наибольших групп по размеру?",
        "option_a": "groupby().size().nlargest(n)",
        "option_b": "groupby().top(n)",
        "option_c": "groupby().largest(n)",
        "option_d": "groupby().biggest(n)",
        "correct_option": "A",
        "explanation": "size() возвращает размер групп, nlargest(n) выбирает n наибольших.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как посчитать произведение значений в группе?",
        "option_a": "groupby().prod()",
        "option_b": "groupby().product()",
        "option_c": "groupby().multiply()",
        "option_d": "groupby().times()",
        "correct_option": "A",
        "explanation": "prod() вычисляет произведение значений в каждой группе.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как получить кумулятивную сумму внутри групп?",
        "option_a": "groupby().cumsum()",
        "option_b": "groupby().cumulative_sum()",
        "option_c": "groupby().running_sum()",
        "option_d": "groupby().acc_sum()",
        "correct_option": "A",
        "explanation": "cumsum() вычисляет кумулятивную сумму внутри каждой группы.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как отфильтровать группы по размеру?",
        "option_a": "groupby().filter(lambda x: len(x) > 5)",
        "option_b": "groupby().size_filter(5)",
        "option_c": "groupby().where(size > 5)",
        "option_d": "groupby().select(lambda x: len(x) > 5)",
        "correct_option": "A",
        "explanation": "filter() позволяет отфильтровать группы на основе условия.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как получить ранг значений внутри группы?",
        "option_a": "groupby().rank()",
        "option_b": "groupby().position()",
        "option_c": "groupby().order()",
        "option_d": "groupby().index()",
        "correct_option": "A",
        "explanation": "rank() присваивает ранг каждому значению внутри группы.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить количество уникальных значений в группе?",
        "option_a": "groupby().nunique()",
        "option_b": "groupby().unique_count()",
        "option_c": "groupby().distinct()",
        "option_d": "groupby().n_unique()",
        "correct_option": "A",
        "explanation": "nunique() подсчитывает количество уникальных значений в каждой группе.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить процентиль для каждой группы?",
        "option_a": "groupby().quantile(0.75)",
        "option_b": "groupby().percentile(75)",
        "option_c": "groupby().pct(0.75)",
        "option_d": "groupby().quartile(0.75)",
        "correct_option": "A",
        "explanation": "quantile() вычисляет квантили для каждой группы.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как сгруппировать по временному интервалу?",
        "option_a": "df.groupby(pd.Grouper(key='date', freq='M'))",
        "option_b": "df.groupby_time('date', 'M')",
        "option_c": "df.time_group('date', 'M')",
        "option_d": "df.resample('M').groupby()",
        "correct_option": "A",
        "explanation": "pd.Grouper позволяет группировать по временным интервалам.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить описательную статистику для групп?",
        "option_a": "groupby().describe()",
        "option_b": "groupby().stats()",
        "option_c": "groupby().summary()",
        "option_d": "groupby().info()",
        "correct_option": "A",
        "explanation": "describe() возвращает статистическое описание для каждой группы.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить кумулятивное произведение в группах?",
        "option_a": "groupby().cumprod()",
        "option_b": "groupby().cumulative_product()",
        "option_c": "groupby().running_product()",
        "option_d": "groupby().acc_prod()",
        "correct_option": "A",
        "explanation": "cumprod() вычисляет кумулятивное произведение внутри каждой группы.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как применить разные функции к разным колонкам с именованием?",
        "option_a": "groupby().agg(col1=('col1', 'mean'), col2=('col2', 'sum'))",
        "option_b": "groupby().agg_named({'col1': 'mean', 'col2': 'sum'})",
        "option_c": "groupby().aggregate_as({'col1': 'mean', 'col2': 'sum'})",
        "option_d": "groupby().named_agg('col1', 'mean', 'col2', 'sum')",
        "correct_option": "A",
        "explanation": "agg() с именованными кортежами создает результат с пользовательскими именами колонок.",
    },
]

# Дополнительные вопросы по теме "Работа с пропущенными данными"
missing_data_questions_2 = [
    {
        "difficulty": "beginner",
        "question_text": "Какое значение представляет пропущенные данные в pandas?",
        "option_a": "NaN (Not a Number)",
        "option_b": "NULL",
        "option_c": "None",
        "option_d": "Все варианты",
        "correct_option": "D",
        "explanation": "pandas интерпретирует NaN, None и NULL как пропущенные значения.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как проверить отсутствие пропущенных значений?",
        "option_a": "df.notna()",
        "option_b": "df.notnull()",
        "option_c": "~df.isna()",
        "option_d": "Все варианты",
        "correct_option": "D",
        "explanation": "Все три способа проверяют на отсутствие пропущенных значений.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как заполнить пропуски интерполяцией?",
        "option_a": "df.interpolate()",
        "option_b": "df.fillna(method='interpolate')",
        "option_c": "df.fill_interpolate()",
        "option_d": "df.interp()",
        "correct_option": "A",
        "explanation": "interpolate() заполняет пропуски интерполированными значениями.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как удалить колонки со всеми пропущенными значениями?",
        "option_a": "df.dropna(axis=1, how='all')",
        "option_b": "df.drop_null_columns()",
        "option_c": "df.remove_empty_cols()",
        "option_d": "df.clean_columns()",
        "correct_option": "A",
        "explanation": "dropna(axis=1, how='all') удаляет колонки, где все значения - NaN.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как заполнить пропуски разными значениями для разных колонок?",
        "option_a": "df.fillna({'col1': 0, 'col2': 'N/A'})",
        "option_b": "df.fillna_dict({'col1': 0, 'col2': 'N/A'})",
        "option_c": "df.fill({'col1': 0, 'col2': 'N/A'})",
        "option_d": "df.replace_na({'col1': 0, 'col2': 'N/A'})",
        "correct_option": "A",
        "explanation": "fillna() принимает словарь с колонками и значениями для заполнения.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как ограничить количество заполняемых пропусков при forward fill?",
        "option_a": "df.fillna(method='ffill', limit=2)",
        "option_b": "df.ffill(max=2)",
        "option_c": "df.forward_fill(limit=2)",
        "option_d": "df.fillna('ffill', count=2)",
        "correct_option": "A",
        "explanation": "Параметр limit ограничивает количество последовательных заполнений.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как проверить есть ли пропущенные значения в конкретной колонке?",
        "option_a": "df['col'].isna().any()",
        "option_b": "df['col'].has_null()",
        "option_c": "df['col'].check_na()",
        "option_d": "df['col'].contains_null()",
        "correct_option": "A",
        "explanation": "isna().any() возвращает True, если есть хотя бы один NaN.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как удалить строки с пропусками в определенной колонке?",
        "option_a": "df.dropna(subset=['col'])",
        "option_b": "df.dropna(column='col')",
        "option_c": "df.drop_null('col')",
        "option_d": "df.remove_na('col')",
        "correct_option": "A",
        "explanation": "subset указывает колонки для проверки на пропущенные значения.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как заменить пропуски на значения из другой колонки?",
        "option_a": "df['col1'].fillna(df['col2'])",
        "option_b": "df['col1'].replace_na(df['col2'])",
        "option_c": "df.fill_from('col1', 'col2')",
        "option_d": "df.coalesce('col1', 'col2')",
        "correct_option": "A",
        "explanation": "fillna() может принимать Series для заполнения пропусков значениями из другой колонки.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как удалить строки с более чем n пропущенными значениями?",
        "option_a": "df.dropna(thresh=len(df.columns) - n)",
        "option_b": "df.dropna(max_na=n)",
        "option_c": "df.drop_if_na(n)",
        "option_d": "df.remove_na(threshold=n)",
        "correct_option": "A",
        "explanation": "thresh указывает минимальное количество непустых значений для сохранения строки.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как создать маску пропущенных значений?",
        "option_a": "df.isna()",
        "option_b": "df.null_mask()",
        "option_c": "df.get_na_mask()",
        "option_d": "df.missing_mask()",
        "correct_option": "A",
        "explanation": "isna() возвращает DataFrame булевых значений, показывающий пропуски.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как заполнить пропуски линейной интерполяцией?",
        "option_a": "df.interpolate(method='linear')",
        "option_b": "df.fillna(method='linear')",
        "option_c": "df.linear_fill()",
        "option_d": "df.fill_linear()",
        "correct_option": "A",
        "explanation": "interpolate(method='linear') использует линейную интерполяцию.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как подсчитать процент пропущенных значений?",
        "option_a": "df.isna().sum() / len(df) * 100",
        "option_b": "df.null_percent()",
        "option_c": "df.missing_rate()",
        "option_d": "df.na_percentage()",
        "correct_option": "A",
        "explanation": "Деление количества пропусков на длину DataFrame дает процент.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Синоним какого метода является isna()?",
        "option_a": "isnull()",
        "option_b": "is_null()",
        "option_c": "check_null()",
        "option_d": "has_null()",
        "correct_option": "A",
        "explanation": "isna() и isnull() - это синонимы в pandas.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как заполнить пропуски с помощью метода pad/ffill только внутри групп?",
        "option_a": "df.groupby('group').fillna(method='ffill')",
        "option_b": "df.fillna(method='ffill', by='group')",
        "option_c": "df.group_fillna('group', 'ffill')",
        "option_d": "df.ffill(group_by='group')",
        "correct_option": "A",
        "explanation": "Группировка перед fillna() применяет заполнение внутри каждой группы.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как заполнить пропуски модой (наиболее частым значением)?",
        "option_a": "df.fillna(df.mode().iloc[0])",
        "option_b": "df.fillna(df.most_common())",
        "option_c": "df.fill_mode()",
        "option_d": "df.fillna(method='mode')",
        "correct_option": "A",
        "explanation": "mode() возвращает наиболее частые значения, iloc[0] выбирает первое.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как заменить определенное значение на NaN?",
        "option_a": "df.replace(value, np.nan)",
        "option_b": "df.to_nan(value)",
        "option_c": "df.make_na(value)",
        "option_d": "df.set_null(value)",
        "correct_option": "A",
        "explanation": "replace() может заменить любое значение на NaN.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как удалить строки где хотя бы n колонок имеют пропуски?",
        "option_a": "df[df.isna().sum(axis=1) < n]",
        "option_b": "df.dropna(min_na=n)",
        "option_c": "df.drop_if(na_count=n)",
        "option_d": "df.remove_rows(null_threshold=n)",
        "correct_option": "A",
        "explanation": "Подсчет пропусков по строкам и фильтрация по условию.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как заполнить пропуски с использованием пользовательской функции?",
        "option_a": "df.fillna(df.apply(lambda x: custom_func(x)))",
        "option_b": "df.fillna(custom_func)",
        "option_c": "df.fill_with_func(custom_func)",
        "option_d": "df.custom_fill(custom_func)",
        "correct_option": "A",
        "explanation": "apply() с пользовательской функцией может генерировать значения для заполнения.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить DataFrame только из строк без пропусков?",
        "option_a": "df.dropna()",
        "option_b": "df[df.notna().all(axis=1)]",
        "option_c": "df[~df.isna().any(axis=1)]",
        "option_d": "Все варианты",
        "correct_option": "D",
        "explanation": "Все три способа возвращают строки без пропущенных значений.",
    },
]

def main():
    """Add all questions to the database."""
    # Get topics
    topic_df = Topic.objects.get(name="Основы DataFrame")
    topic_series = Topic.objects.get(name="Основы Series")
    topic_indexing = Topic.objects.get(name="Индексация и выбор данных")
    topic_groupby = Topic.objects.get(name="GroupBy и агрегация")
    topic_missing = Topic.objects.get(name="Работа с пропущенными данными")

    questions_data = [
        (topic_df, dataframe_questions_2),
        (topic_series, series_questions_2),
        (topic_indexing, indexing_questions_2),
        (topic_groupby, groupby_questions_2),
        (topic_missing, missing_data_questions_2),
    ]

    total_added = 0
    for topic, questions in questions_data:
        for q_data in questions:
            question = Question.objects.create(
                topic=topic,
                question_type='multiple_choice',
                difficulty=q_data['difficulty'],
                question_text=q_data['question_text'],
                option_a=q_data['option_a'],
                option_b=q_data['option_b'],
                option_c=q_data['option_c'],
                option_d=q_data['option_d'],
                correct_option=q_data['correct_option'],
                explanation=q_data['explanation'],
                is_active=True,
            )
            total_added += 1
            print(f"✓ Добавлен вопрос {total_added}: {q_data['question_text'][:50]}...")

    print(f"\n✅ Всего добавлено {total_added} вопросов!")

    # Print statistics
    print("\nОбщая статистика по уровням сложности:")
    for level in ['beginner', 'intermediate', 'advanced']:
        count = Question.objects.filter(difficulty=level, is_active=True).count()
        print(f"  {level}: {count} вопросов")

    print("\nОбщая статистика по темам:")
    for topic in Topic.objects.all():
        count = Question.objects.filter(topic=topic, is_active=True).count()
        print(f"  {topic.name}: {count} вопросов")

    total_active = Question.objects.filter(is_active=True).count()
    print(f"\n🎯 Всего активных вопросов в базе: {total_active}")

if __name__ == '__main__':
    main()
