#!/usr/bin/env python
"""Script to add 50 multiple choice questions about pandas."""

import init_django
from questions.models import Topic, Question

# Вопросы по теме "Основы DataFrame"
dataframe_questions = [
    {
        "difficulty": "beginner",
        "question_text": "Как создать пустой DataFrame?",
        "option_a": "pd.DataFrame()",
        "option_b": "pd.EmptyDataFrame()",
        "option_c": "pd.create_dataframe()",
        "option_d": "pd.new_df()",
        "correct_option": "A",
        "explanation": "pd.DataFrame() создает пустой DataFrame. Это самый простой способ создания пустого DataFrame.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Какой метод используется для просмотра первых строк DataFrame?",
        "option_a": "df.first()",
        "option_b": "df.head()",
        "option_c": "df.top()",
        "option_d": "df.show()",
        "correct_option": "B",
        "explanation": "Метод head() по умолчанию показывает первые 5 строк DataFrame.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить информацию о типах данных в DataFrame?",
        "option_a": "df.dtypes",
        "option_b": "df.types",
        "option_c": "df.info_types()",
        "option_d": "df.get_types()",
        "correct_option": "A",
        "explanation": "Атрибут dtypes возвращает типы данных для каждой колонки.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Какой метод возвращает размерность DataFrame (строки, столбцы)?",
        "option_a": "df.size",
        "option_b": "df.shape",
        "option_c": "df.dimensions",
        "option_d": "df.dim()",
        "correct_option": "B",
        "explanation": "df.shape возвращает кортеж (количество_строк, количество_столбцов).",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как переименовать колонки в DataFrame?",
        "option_a": "df.rename_columns()",
        "option_b": "df.set_columns()",
        "option_c": "df.rename(columns={})",
        "option_d": "df.change_names()",
        "correct_option": "C",
        "explanation": "Метод rename() с параметром columns позволяет переименовать колонки.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как удалить колонку из DataFrame?",
        "option_a": "df.remove('column')",
        "option_b": "df.drop('column', axis=1)",
        "option_c": "df.delete('column')",
        "option_d": "del df['column']",
        "correct_option": "B",
        "explanation": "df.drop('column', axis=1) удаляет колонку. axis=1 указывает на столбцы.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Какой метод используется для сортировки DataFrame по значениям колонки?",
        "option_a": "df.sort('column')",
        "option_b": "df.sort_values('column')",
        "option_c": "df.order_by('column')",
        "option_d": "df.arrange('column')",
        "correct_option": "B",
        "explanation": "sort_values() сортирует DataFrame по значениям указанной колонки.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Что делает параметр inplace=True в методах pandas?",
        "option_a": "Создает копию данных",
        "option_b": "Изменяет объект на месте без создания копии",
        "option_c": "Удаляет оригинальный объект",
        "option_d": "Ускоряет выполнение операции",
        "correct_option": "B",
        "explanation": "inplace=True изменяет объект на месте и возвращает None вместо новой копии.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как объединить два DataFrame по горизонтали?",
        "option_a": "pd.merge(df1, df2)",
        "option_b": "pd.concat([df1, df2], axis=1)",
        "option_c": "pd.join(df1, df2)",
        "option_d": "df1.append(df2)",
        "correct_option": "B",
        "explanation": "pd.concat() с axis=1 объединяет DataFrame по горизонтали (добавляет столбцы).",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить список всех колонок в DataFrame?",
        "option_a": "df.columns",
        "option_b": "df.cols",
        "option_c": "df.column_names",
        "option_d": "df.get_columns()",
        "correct_option": "A",
        "explanation": "Атрибут columns возвращает Index с именами всех колонок.",
    },
]

# Вопросы по теме "Основы Series"
series_questions = [
    {
        "difficulty": "beginner",
        "question_text": "Как создать Series из списка?",
        "option_a": "pd.Series([1, 2, 3])",
        "option_b": "pd.CreateSeries([1, 2, 3])",
        "option_c": "pd.new_series([1, 2, 3])",
        "option_d": "pd.array([1, 2, 3])",
        "correct_option": "A",
        "explanation": "pd.Series() создает Series из переданного списка или массива.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Чем Series отличается от списка Python?",
        "option_a": "Ничем, это одно и то же",
        "option_b": "Series имеет индексы и поддерживает векторные операции",
        "option_c": "Series медленнее списка",
        "option_d": "Series не может содержать числа",
        "correct_option": "B",
        "explanation": "Series - это одномерный массив с метками (индексами) и поддержкой векторных операций.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как получить уникальные значения из Series?",
        "option_a": "series.unique()",
        "option_b": "series.distinct()",
        "option_c": "series.get_unique()",
        "option_d": "set(series)",
        "correct_option": "A",
        "explanation": "Метод unique() возвращает массив уникальных значений из Series.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как подсчитать количество уникальных значений в Series?",
        "option_a": "series.count_unique()",
        "option_b": "series.nunique()",
        "option_c": "len(series.unique())",
        "option_d": "series.n_unique()",
        "correct_option": "B",
        "explanation": "Метод nunique() возвращает количество уникальных значений (исключая NaN).",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Какой метод используется для подсчета частоты значений в Series?",
        "option_a": "series.count()",
        "option_b": "series.frequency()",
        "option_c": "series.value_counts()",
        "option_d": "series.count_values()",
        "correct_option": "C",
        "explanation": "value_counts() возвращает Series с частотой каждого уникального значения.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как применить функцию к каждому элементу Series?",
        "option_a": "series.map(func)",
        "option_b": "series.foreach(func)",
        "option_c": "series.transform(func)",
        "option_d": "series.process(func)",
        "correct_option": "A",
        "explanation": "Метод map() применяет функцию к каждому элементу Series. Также можно использовать apply().",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить первый элемент Series?",
        "option_a": "series[0]",
        "option_b": "series.first",
        "option_c": "series.get(0)",
        "option_d": "series.head(1)",
        "correct_option": "A",
        "explanation": "Series поддерживает индексацию, поэтому series[0] возвращает первый элемент.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как сбросить индекс Series?",
        "option_a": "series.reset_index(drop=True)",
        "option_b": "series.clear_index()",
        "option_c": "series.reindex()",
        "option_d": "series.new_index()",
        "correct_option": "A",
        "explanation": "reset_index(drop=True) сбрасывает индекс и не сохраняет старый индекс как колонку.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как получить тип данных Series?",
        "option_a": "series.type",
        "option_b": "series.dtype",
        "option_c": "series.datatype",
        "option_d": "type(series)",
        "correct_option": "B",
        "explanation": "Атрибут dtype возвращает тип данных элементов Series.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Что возвращает series.str.split()?",
        "option_a": "Список строк",
        "option_b": "Series со списками строк",
        "option_c": "DataFrame",
        "option_d": "Ошибку",
        "correct_option": "B",
        "explanation": "str.split() возвращает Series, где каждый элемент - список разделенных строк.",
    },
]

# Вопросы по теме "Индексация и выбор данных"
indexing_questions = [
    {
        "difficulty": "beginner",
        "question_text": "Как выбрать одну колонку из DataFrame?",
        "option_a": "df['column']",
        "option_b": "df.get('column')",
        "option_c": "df.select('column')",
        "option_d": "df.column_select('column')",
        "correct_option": "A",
        "explanation": "Квадратные скобки с именем колонки - основной способ выбора одной колонки.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как выбрать несколько колонок из DataFrame?",
        "option_a": "df['col1', 'col2']",
        "option_b": "df[['col1', 'col2']]",
        "option_c": "df.select(['col1', 'col2'])",
        "option_d": "df.get(['col1', 'col2'])",
        "correct_option": "B",
        "explanation": "Двойные квадратные скобки с списком имен колонок выбирают несколько колонок.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать строки по условию?",
        "option_a": "df.where(df['col'] > 5)",
        "option_b": "df[df['col'] > 5]",
        "option_c": "df.select(df['col'] > 5)",
        "option_d": "df.filter('col > 5')",
        "correct_option": "B",
        "explanation": "Передача булевой маски в квадратные скобки фильтрует строки по условию.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать строку по индексу iloc?",
        "option_a": "df.iloc[0]",
        "option_b": "df[0]",
        "option_c": "df.row(0)",
        "option_d": "df.get_row(0)",
        "correct_option": "A",
        "explanation": "iloc использует целочисленную индексацию для выбора строк по позиции.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Чем отличается loc от iloc?",
        "option_a": "Ничем",
        "option_b": "loc использует метки индекса, iloc использует позиции",
        "option_c": "loc быстрее iloc",
        "option_d": "iloc работает только с числами",
        "correct_option": "B",
        "explanation": "loc использует метки (labels), iloc использует целочисленные позиции.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать срез строк с 2 по 5?",
        "option_a": "df[2:5]",
        "option_b": "df.iloc[2:5]",
        "option_c": "df.rows[2:5]",
        "option_d": "df.slice(2, 5)",
        "correct_option": "B",
        "explanation": "iloc[2:5] выбирает строки с индексами 2, 3, 4 (5 не включается).",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как выбрать конкретную ячейку по метке строки и столбца?",
        "option_a": "df.at['row', 'col']",
        "option_b": "df.get('row', 'col')",
        "option_c": "df.cell['row', 'col']",
        "option_d": "df['row']['col']",
        "correct_option": "A",
        "explanation": "at[] обеспечивает быстрый доступ к скалярному значению по метке.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как выбрать последние 10 строк DataFrame?",
        "option_a": "df.last(10)",
        "option_b": "df.tail(10)",
        "option_c": "df.bottom(10)",
        "option_d": "df.end(10)",
        "correct_option": "B",
        "explanation": "Метод tail(n) возвращает последние n строк DataFrame.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как выбрать строки где значение колонки входит в список?",
        "option_a": "df[df['col'].in_list([1, 2, 3])]",
        "option_b": "df[df['col'].isin([1, 2, 3])]",
        "option_c": "df[df['col'].contains([1, 2, 3])]",
        "option_d": "df.filter('col', [1, 2, 3])",
        "correct_option": "B",
        "explanation": "Метод isin() проверяет, содержится ли значение в переданном списке.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как выбрать строки с определенными индексами?",
        "option_a": "df.loc[[index1, index2]]",
        "option_b": "df[index1, index2]",
        "option_c": "df.select([index1, index2])",
        "option_d": "df.get_rows([index1, index2])",
        "correct_option": "A",
        "explanation": "loc с списком индексов выбирает строки по их меткам.",
    },
]

# Вопросы по теме "GroupBy и агрегация"
groupby_questions = [
    {
        "difficulty": "intermediate",
        "question_text": "Какой метод применяет функцию к каждой группе?",
        "option_a": "groupby().map()",
        "option_b": "groupby().apply()",
        "option_c": "groupby().transform()",
        "option_d": "groupby().execute()",
        "correct_option": "B",
        "explanation": "apply() применяет функцию к каждой группе и объединяет результаты.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как подсчитать количество элементов в каждой группе?",
        "option_a": "groupby().count()",
        "option_b": "groupby().size()",
        "option_c": "groupby().length()",
        "option_d": "groupby().num()",
        "correct_option": "B",
        "explanation": "size() возвращает количество элементов в каждой группе, включая NaN.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как применить несколько агрегирующих функций к группам?",
        "option_a": "groupby().agg(['mean', 'sum'])",
        "option_b": "groupby().aggregate(['mean', 'sum'])",
        "option_c": "groupby().multi(['mean', 'sum'])",
        "option_d": "Оба A и B",
        "correct_option": "D",
        "explanation": "agg() и aggregate() - это синонимы и оба принимают список функций.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Что делает метод transform() в groupby?",
        "option_a": "Изменяет группы",
        "option_b": "Возвращает результат той же формы что и исходный DataFrame",
        "option_c": "Удаляет группы",
        "option_d": "Сортирует группы",
        "correct_option": "B",
        "explanation": "transform() возвращает объект того же размера, что и входной.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как найти максимальное значение в каждой группе?",
        "option_a": "groupby().max()",
        "option_b": "groupby().maximum()",
        "option_c": "groupby().largest()",
        "option_d": "groupby().top()",
        "correct_option": "A",
        "explanation": "max() возвращает максимальное значение для каждой группы.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как сгруппировать по нескольким колонкам?",
        "option_a": "df.groupby('col1', 'col2')",
        "option_b": "df.groupby(['col1', 'col2'])",
        "option_c": "df.group_by_multi(['col1', 'col2'])",
        "option_d": "df.groupby().multi(['col1', 'col2'])",
        "correct_option": "B",
        "explanation": "groupby() принимает список колонок для группировки по нескольким столбцам.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как получить первую строку из каждой группы?",
        "option_a": "groupby().first()",
        "option_b": "groupby().head(1)",
        "option_c": "groupby().top()",
        "option_d": "groupby()[0]",
        "correct_option": "A",
        "explanation": "first() возвращает первое ненулевое значение каждой группы.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как применить разные функции к разным колонкам?",
        "option_a": "groupby().agg({'col1': 'mean', 'col2': 'sum'})",
        "option_b": "groupby().apply_different()",
        "option_c": "groupby().multi_agg()",
        "option_d": "Невозможно",
        "correct_option": "A",
        "explanation": "agg() принимает словарь с колонками и функциями для каждой.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как посчитать сумму для каждой группы?",
        "option_a": "groupby().sum()",
        "option_b": "groupby().total()",
        "option_c": "groupby().add()",
        "option_d": "groupby().accumulate()",
        "correct_option": "A",
        "explanation": "sum() вычисляет сумму значений для каждой группы.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Что делает параметр as_index=False в groupby?",
        "option_a": "Удаляет индекс",
        "option_b": "Делает колонку группировки обычной колонкой, а не индексом",
        "option_c": "Сбрасывает все индексы",
        "option_d": "Ничего",
        "correct_option": "B",
        "explanation": "as_index=False предотвращает использование колонок группировки как индекса результата.",
    },
]

# Вопросы по теме "Работа с пропущенными данными"
missing_data_questions = [
    {
        "difficulty": "beginner",
        "question_text": "Как проверить наличие пропущенных значений?",
        "option_a": "df.isnull()",
        "option_b": "df.is_null()",
        "option_c": "df.check_null()",
        "option_d": "df.has_null()",
        "correct_option": "A",
        "explanation": "isnull() возвращает булевую маску с True для пропущенных значений.",
    },
    {
        "difficulty": "beginner",
        "question_text": "Как подсчитать количество пропущенных значений в каждой колонке?",
        "option_a": "df.isnull().count()",
        "option_b": "df.isnull().sum()",
        "option_c": "df.count_null()",
        "option_d": "df.null_count()",
        "correct_option": "B",
        "explanation": "isnull().sum() подсчитывает True значения (пропуски) для каждой колонки.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как заполнить пропущенные значения нулями?",
        "option_a": "df.fillna(0)",
        "option_b": "df.fill_null(0)",
        "option_c": "df.replace_na(0)",
        "option_d": "df.fill(0)",
        "correct_option": "A",
        "explanation": "fillna(0) заменяет все NaN значения на 0.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как заполнить пропуски предыдущим значением (forward fill)?",
        "option_a": "df.fillna(method='ffill')",
        "option_b": "df.forward_fill()",
        "option_c": "df.fill_forward()",
        "option_d": "df.propagate()",
        "correct_option": "A",
        "explanation": "fillna(method='ffill') заполняет пропуски предыдущим непропущенным значением.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как заполнить пропуски следующим значением (backward fill)?",
        "option_a": "df.fillna(method='bfill')",
        "option_b": "df.backward_fill()",
        "option_c": "df.fill_back()",
        "option_d": "df.reverse_fill()",
        "correct_option": "A",
        "explanation": "fillna(method='bfill') заполняет пропуски следующим непропущенным значением.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как заполнить пропуски средним значением колонки?",
        "option_a": "df.fillna(df.mean())",
        "option_b": "df.fillna(df.average())",
        "option_c": "df.fill_mean()",
        "option_d": "df.replace_na_mean()",
        "correct_option": "A",
        "explanation": "df.mean() вычисляет среднее для каждой колонки, fillna() использует эти значения.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как удалить строки с любыми пропущенными значениями?",
        "option_a": "df.dropna()",
        "option_b": "df.drop_null()",
        "option_c": "df.remove_na()",
        "option_d": "df.delete_na()",
        "correct_option": "A",
        "explanation": "dropna() удаляет строки, содержащие хотя бы одно NaN значение.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как удалить строки где все значения пропущены?",
        "option_a": "df.dropna(how='all')",
        "option_b": "df.dropna(all=True)",
        "option_c": "df.drop_all_na()",
        "option_d": "df.dropna(complete=True)",
        "correct_option": "A",
        "explanation": "dropna(how='all') удаляет только те строки, где все значения - NaN.",
    },
    {
        "difficulty": "advanced",
        "question_text": "Как удалить колонки с пропущенными значениями?",
        "option_a": "df.dropna(axis=1)",
        "option_b": "df.dropna(columns=True)",
        "option_c": "df.drop_columns_na()",
        "option_d": "df.dropna().T",
        "correct_option": "A",
        "explanation": "dropna(axis=1) применяет удаление к колонкам вместо строк.",
    },
    {
        "difficulty": "intermediate",
        "question_text": "Как проверить есть ли хотя бы одно пропущенное значение в DataFrame?",
        "option_a": "df.isnull().any().any()",
        "option_b": "df.has_null()",
        "option_c": "df.check_na()",
        "option_d": "df.any_null()",
        "correct_option": "A",
        "explanation": "Первый any() проверяет колонки, второй any() проверяет результат по всем колонкам.",
    },
]

def main():
    """Add all questions to the database."""
    # Get topics
    topic_df = Topic.objects.get(name="Основы DataFrame")
    topic_series = Topic.objects.get(name="Основы Series")
    topic_indexing = Topic.objects.get(name="Индексация и выбор данных")
    topic_groupby = Topic.objects.get(name="GroupBy и агрегация")
    topic_missing = Topic.objects.get(name="Работа с пропущенными данными")

    questions_data = [
        (topic_df, dataframe_questions),
        (topic_series, series_questions),
        (topic_indexing, indexing_questions),
        (topic_groupby, groupby_questions),
        (topic_missing, missing_data_questions),
    ]

    total_added = 0
    for topic, questions in questions_data:
        for q_data in questions:
            question = Question.objects.create(
                topic=topic,
                question_type='multiple_choice',
                difficulty=q_data['difficulty'],
                question_text=q_data['question_text'],
                option_a=q_data['option_a'],
                option_b=q_data['option_b'],
                option_c=q_data['option_c'],
                option_d=q_data['option_d'],
                correct_option=q_data['correct_option'],
                explanation=q_data['explanation'],
                is_active=True,
            )
            total_added += 1
            print(f"✓ Добавлен вопрос: {q_data['question_text'][:60]}...")

    print(f"\n✅ Всего добавлено {total_added} вопросов!")

    # Print statistics
    print("\nСтатистика по уровням сложности:")
    for level in ['beginner', 'intermediate', 'advanced']:
        count = Question.objects.filter(difficulty=level, is_active=True).count()
        print(f"  {level}: {count} вопросов")

    print("\nСтатистика по темам:")
    for topic in Topic.objects.all():
        count = Question.objects.filter(topic=topic, is_active=True).count()
        print(f"  {topic.name}: {count} вопросов")

if __name__ == '__main__':
    main()
